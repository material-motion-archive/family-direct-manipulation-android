/*
 * Copyright 2016-present The Material Motion Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.android.material.motion.family.directmanipulation;

import android.support.annotation.Nullable;
import android.support.annotation.VisibleForTesting;
import android.view.View;

import com.google.android.material.motion.gestures.DragGestureRecognizer;
import com.google.android.material.motion.gestures.RotateGestureRecognizer;
import com.google.android.material.motion.gestures.ScaleGestureRecognizer;
import com.google.android.material.motion.runtime.Performer;
import com.google.android.material.motion.runtime.PerformerFeatures.ComposablePerforming;
import com.google.android.material.motion.runtime.Plan;

/**
 * Makes the target draggable, pinchable, and rotatable.
 * <p>
 * Note that this will overwrite the {@link Performer#target target}'s {@link
 * View.OnTouchListener}.
 */
public class DirectlyManipulable extends Plan<View> {

  @VisibleForTesting
  final DragGestureRecognizer dragGestureRecognizer;
  @VisibleForTesting
  final ScaleGestureRecognizer scaleGestureRecognizer;
  @VisibleForTesting
  final RotateGestureRecognizer rotateGestureRecognizer;

  /**
   * Creates a plan with a new drag, pinch, and rotation gesture recognizer.
   */
  public DirectlyManipulable() {
    this(null, null, null);
  }

  /**
   * Creates a plan with existing gesture recognizers. Events generated by the provided gesture
   * recognizers will be observed.
   */
  public DirectlyManipulable(
    @Nullable DragGestureRecognizer dragGestureRecognizer,
    @Nullable ScaleGestureRecognizer scaleGestureRecognizer,
    @Nullable RotateGestureRecognizer rotateGestureRecognizer) {
    this.dragGestureRecognizer = dragGestureRecognizer != null
      ? dragGestureRecognizer : new DragGestureRecognizer();
    this.scaleGestureRecognizer = scaleGestureRecognizer != null
      ? scaleGestureRecognizer : new ScaleGestureRecognizer();
    this.rotateGestureRecognizer = rotateGestureRecognizer != null
      ? rotateGestureRecognizer : new RotateGestureRecognizer();
  }

  @Override
  public Class<? extends Performer<View>> getPerformerClass() {
    return DirectlyManipulablePerformer.class;
  }

  /**
   * A performer that composes to {@link Draggable}, {@link Pinchable}, and {@link Rotatable}.
   */
  public static class DirectlyManipulablePerformer extends Performer<View>
    implements ComposablePerforming<View> {

    private PlanEmitter<View> planEmitter;

    @Override
    public void addPlan(Plan<View> plan) {
      DirectlyManipulable directlyManipulable = (DirectlyManipulable) plan;
      planEmitter.emit(new Draggable(directlyManipulable.dragGestureRecognizer));
      planEmitter.emit(new Pinchable(directlyManipulable.scaleGestureRecognizer));
      planEmitter.emit(new Rotatable(directlyManipulable.rotateGestureRecognizer));
    }

    @Override
    public void setPlanEmitter(PlanEmitter<View> planEmitter) {
      this.planEmitter = planEmitter;
    }
  }
}
